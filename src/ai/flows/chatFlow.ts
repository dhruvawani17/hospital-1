
'use server';
/**
 * @fileOverview A simple AI chatbot flow for HealthFirst Connect.
 *
 * - `chatWithBot` - A function that handles a user's message and returns the bot's response.
 * - `ChatInput` - The input type for the `chatWithBot` function.
 * - `ChatOutput` - The return type for the `chatWithBot` function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { SERVICES_DATA, APP_NAME, MOCK_TIME_SLOTS } from '@/lib/constants';
import type { Service } from '@/types';

const ChatInputSchema = z.object({
  userInput: z.string().describe('The message sent by the user to the chatbot.'),
});
export type ChatInput = z.infer<typeof ChatInputSchema>;

const ChatOutputSchema = z.object({
  botResponse: z.string().describe('The text response generated by the chatbot.'),
  bookingInitiation: z
    .object({
      serviceId: z.string(),
      serviceName: z.string(),
    })
    .optional()
    .describe('If present, the chatbot has identified an intent to book an appointment for this service and will redirect to the booking form.'),
  bookingConfirmation: z
    .object({
      transactionId: z.string(),
      serviceId: z.string(),
      serviceName: z.string(),
      date: z.string(), // Storing as string, to be parsed by client
      time: z.string(),
      patientName: z.string(),
      patientEmail: z.string(),
      patientPhone: z.string().optional(),
      price: z.number(),
      receiptUrl: z.string(),
      // confirmationMessage is now part of botResponse
    })
    .optional()
    .describe('If present, the chatbot has successfully booked the appointment and this contains confirmation details for client-side processing.')
});
export type ChatOutput = z.infer<typeof ChatOutputSchema>;


const AppointmentBookingToolInputSchema = z.object({
  serviceId: z.string().describe("The ID of the medical service the user wants to book. This ID must exactly match one of the available service IDs from the list provided in the prompt."),
  patientName: z.string().optional().describe("Patient's full name, if collected."),
  patientEmail: z.string().email().optional().describe("Patient's email address, if collected."),
  patientPhone: z.string().optional().describe("Patient's phone number, if collected."),
  desiredDateStr: z.string().optional().describe("Desired date for the appointment (e.g., YYYY-MM-DD format), if collected."),
  desiredTimeStr: z.string().optional().describe("Desired time for the appointment (e.g., HH:MM AM/PM format from the provided list), if collected.")
});

const initiateAppointmentBookingTool = ai.defineTool(
  {
    name: 'initiateAppointmentBooking',
    description: `Use this tool to either initiate an appointment booking by redirecting to a form, or to finalize an appointment if all details (service, name, email, phone, date, time) have been collected directly in the chat.`,
    inputSchema: AppointmentBookingToolInputSchema,
    outputSchema: z.object({ // This output is for the tool's execution, not directly for the LLM in this setup
      success: z.boolean(),
      message: z.string().optional(),
      detailsProvided: AppointmentBookingToolInputSchema.optional(),
    }),
  },
  async (input) => {
    // This tool primarily signals intent and passes data. The flow handles the logic.
    const serviceExists = SERVICES_DATA.some(s => s.id === input.serviceId);
    if (!serviceExists) {
      return { success: false, message: `Service ID ${input.serviceId} is not a valid service.` };
    }
    return { success: true, detailsProvided: input, message: "Tool call successful." };
  }
);

export async function chatWithBot(input: ChatInput): Promise<ChatOutput> {
  return chatFlow(input);
}

const serviceListForPrompt = SERVICES_DATA.map(s => `- ${s.name} (ID: ${s.id}, Price: â‚¹${s.price.toFixed(2)})`).join('\n');
const timeSlotsForPrompt = MOCK_TIME_SLOTS.join(', ');

const chatPrompt = ai.definePrompt({
  name: 'chatFlowPrompt',
  input: {schema: ChatInputSchema},
  tools: [initiateAppointmentBookingTool],
  prompt: `You are "MediBuddy", a friendly and helpful AI assistant for ${APP_NAME}, a modern medical clinic.
Your goal is to assist users with information about our services, help them book appointments, answer general questions about our clinic, and provide general, commonly-known wellness tips that are NOT specific medical advice.

Available services at ${APP_NAME} (service name, ID, and price):
${serviceListForPrompt}

Available time slots for appointments: ${timeSlotsForPrompt}.

If the user expresses clear intent to book an appointment for one of these specific services:
1. First, confirm the service they want to book.
2. Then, ask for their full name.
3. After getting their name, ask for their email address.
4. After getting their email, ask for their phone number (optional, they can skip).
5. Then, ask them for their preferred date for the appointment. They should provide it in YYYY-MM-DD format.
6. Finally, ask them for their preferred time from the list of available time slots: ${timeSlotsForPrompt}. They should provide it in HH:MM AM/PM format.
7. Once you have ALL these details (service ID, patient name, patient email, (optional) patient phone, date in YYYY-MM-DD, and time in HH:MM AM/PM format), use the "initiateAppointmentBookingTool" with all this collected information.
8. If the user only mentions a service they want to book but does not want to provide all details in the chat, or if you cannot gather all details after trying, use the "initiateAppointmentBookingTool" with only the 'serviceId'.
9. Do NOT ask for payment details in chat. Booking confirmation in chat is provisional; payment is handled separately if redirected to form, or implied if booked directly (for this simulation).

IMPORTANT:
- You MUST NOT provide any specific medical advice, diagnosis, or treatment suggestions for individual conditions. Your wellness tips should be very general, widely accepted, and not personalized.
- If a user asks for specific medical advice, describes symptoms that could be serious, or asks for a diagnosis, you MUST politely decline and strongly suggest they book an appointment with one of our qualified doctors or seek urgent medical attention if appropriate.
- If you don't know the answer to something, say "I'm sorry, I don't have information on that."
- Keep your responses concise and easy to understand. Be empathetic and patient.

User's question: {{{userInput}}}
Answer as MediBuddy.`,
  config: {
      safetySettings: [
        { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
        { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
        { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
        { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
      ],
    }
});

const chatFlow = ai.defineFlow(
  {
    name: 'chatFlow',
    inputSchema: ChatInputSchema,
    outputSchema: ChatOutputSchema,
  },
  async (input: ChatInput): Promise<ChatOutput> => {
    const llmResponse = await chatPrompt(input);
    const allToolRequests = llmResponse.toolRequests;

    if (allToolRequests && allToolRequests.length > 0) {
      const bookingToolCall = allToolRequests.find(
        (req: { name: string, input: unknown }) => req.name === initiateAppointmentBookingTool.name
      );

      if (bookingToolCall) {
        const toolCallInput = bookingToolCall.input as z.infer<typeof AppointmentBookingToolInputSchema>;
        const service = SERVICES_DATA.find(s => s.id === toolCallInput.serviceId);

        if (!service) {
          return { botResponse: `I couldn't find a service with ID "${toolCallInput.serviceId}". Can you clarify which service you meant from the list?` };
        }

        // Check if all details for direct booking are present
        if (toolCallInput.patientName && toolCallInput.patientEmail && toolCallInput.desiredDateStr && toolCallInput.desiredTimeStr) {
          
          let isValidDate = false;
          let parsedDate: Date;
          try {
            const [year, month, day] = toolCallInput.desiredDateStr.split('-').map(Number);
            // Ensure components are valid numbers before creating date
            if (isNaN(year) || isNaN(month) || isNaN(day) || month < 1 || month > 12 || day < 1 || day > 31) {
              throw new Error("Invalid date components from input string.");
            }
            // Creates a date at local midnight using the provided year, month (0-indexed), and day
            parsedDate = new Date(year, month - 1, day);

            const todayDateOnly = new Date();
            todayDateOnly.setHours(0, 0, 0, 0); // Sets to local midnight today

            // Check if parsedDate is a valid date object and is not in the past
            if (!isNaN(parsedDate.getTime()) && parsedDate >= todayDateOnly) {
                isValidDate = true;
            }
          } catch (e) {
            // isValidDate remains false, error will be caught below
            console.error("Error parsing desiredDateStr:", toolCallInput.desiredDateStr, e);
          }

          if (!isValidDate) {
            return { botResponse: `The date "${toolCallInput.desiredDateStr}" doesn't seem valid, is in the past, or is not in YYYY-MM-DD format. Please provide a date for today or a future date.` };
          }
          if (!MOCK_TIME_SLOTS.includes(toolCallInput.desiredTimeStr)) {
             return { botResponse: `The time "${toolCallInput.desiredTimeStr}" is not a valid slot. Please choose from: ${timeSlotsForPrompt}.` };
          }

          const transactionId = `CHATRCPT-${Date.now()}`;
          const confirmationMessage = `Great! Your appointment for ${service.name} with ${toolCallInput.patientName} on ${toolCallInput.desiredDateStr} at ${toolCallInput.desiredTimeStr} is provisionally booked. Your reference ID is ${transactionId}.`;
          
          return {
            botResponse: confirmationMessage,
            bookingConfirmation: {
              transactionId,
              serviceId: service.id,
              serviceName: service.name,
              date: toolCallInput.desiredDateStr, // Pass as string "YYYY-MM-DD"
              time: toolCallInput.desiredTimeStr,
              patientName: toolCallInput.patientName,
              patientEmail: toolCallInput.patientEmail,
              patientPhone: toolCallInput.patientPhone || '',
              price: service.price,
              receiptUrl: `/receipt?transactionId=${transactionId}`,
            },
          };
        } else {
          // Not all details present, initiate redirect to form
          return {
            botResponse: `Okay, I'll help you book an appointment for ${service.name}. Please wait while I redirect you to the booking form to complete the details.`,
            bookingInitiation: { serviceId: service.id, serviceName: service.name },
          };
        }
      }
    }

    const textResponse = llmResponse.text;
    if (textResponse === null || typeof textResponse === 'undefined' || textResponse.trim() === "") {
        return { botResponse: "I'm having a little trouble responding right now. Please try again in a moment." };
    }
    
    return { botResponse: textResponse };
  }
);

    
