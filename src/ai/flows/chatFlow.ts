'use server';
/**
 * @fileOverview A simple AI chatbot flow for HealthFirst Connect.
 *
 * - `chatWithBot` - A function that handles a user's message and returns the bot's response.
 * - `ChatInput` - The input type for the `chatWithBot` function.
 * - `ChatOutput` - The return type for the `chatWithBot` function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import { SERVICES_DATA, APP_NAME } from '@/lib/constants';
import type { Service } from '@/types';
import type { ToolRequestPart } from 'genkit'; // Import for typing if available, otherwise use 'any'

const ChatInputSchema = z.object({
  userInput: z.string().describe('The message sent by the user to the chatbot.'),
});
export type ChatInput = z.infer<typeof ChatInputSchema>;

const ChatOutputSchema = z.object({
  botResponse: z.string().describe('The text response generated by the chatbot.'),
  bookingInitiation: z
    .object({
      serviceId: z.string(),
      serviceName: z.string(),
    })
    .optional()
    .describe('If present, the chatbot has identified an intent to book an appointment for this service.'),
});
export type ChatOutput = z.infer<typeof ChatOutputSchema>;


const initiateAppointmentBookingTool = ai.defineTool(
  {
    name: 'initiateAppointmentBooking',
    description: `Use this tool ONLY when the user explicitly states they want to book an appointment for a specific medical service offered by ${APP_NAME}. You must identify the service ID. Do not use this tool for general inquiries about services.`,
    inputSchema: z.object({
      serviceId: z.string().describe('The ID of the medical service the user wants to book. This ID must exactly match one of the available service IDs from the list provided in the prompt.'),
    }),
    outputSchema: z.object({ // This output is for the tool's execution, not directly for the LLM in this setup
      success: z.boolean(),
      serviceId: z.string(),
      message: z.string().optional(),
    }),
  },
  async (input) => {
    // This tool primarily signals intent. The client acts on the signal.
    // We can validate if the serviceId exists, though the LLM should get it from the prompt.
    const serviceExists = SERVICES_DATA.some(s => s.id === input.serviceId);
    if (serviceExists) {
      return { success: true, serviceId: input.serviceId, message: `Booking process can be initiated for service ID: ${input.serviceId}.` };
    }
    return { success: false, serviceId: input.serviceId, message: `Service ID ${input.serviceId} is not a valid service. Cannot initiate booking.` };
  }
);

export async function chatWithBot(input: ChatInput): Promise<ChatOutput> {
  return chatFlow(input);
}

const serviceListForPrompt = SERVICES_DATA.map(s => `- ${s.name} (ID: ${s.id})`).join('\n');

const chatPrompt = ai.definePrompt({
  name: 'chatFlowPrompt',
  input: {schema: ChatInputSchema},
  tools: [initiateAppointmentBookingTool],
  prompt: `You are "MediBuddy", a friendly and helpful AI assistant for ${APP_NAME}, a modern medical clinic.
Your goal is to assist users with information about our services, help them understand how to book appointments, answer general questions about our clinic, and provide general, commonly-known wellness tips that are NOT specific medical advice.

You can talk about:
- Our available services (General Consultation, Cardiology, Physiotherapy, Dermatology, Ophthalmology, Pediatrics). You can find details about these services in the app.
- How to book an appointment using the online form.
- General information about ${APP_NAME}.
- General wellness topics and commonly known, non-prescriptive tips for minor, non-urgent issues (e.g., "for a common cold, it's generally advised to get plenty of rest and stay hydrated," or "for a minor headache, ensure you're hydrated and consider resting in a quiet, dark room.").

IMPORTANT:
- You MUST NOT provide any specific medical advice, diagnosis, or treatment suggestions for individual conditions. Your wellness tips should be very general, widely accepted, and not personalized.
- If a user asks for specific medical advice, describes symptoms that could be serious, or asks for a diagnosis, you MUST politely decline and strongly suggest they book an appointment with one of our qualified doctors or seek urgent medical attention if appropriate. For example, say: "While I can share some general wellness information, I'm not qualified to give specific medical advice for your situation. It's best to book an appointment with a doctor who can help." or "For serious concerns, please seek medical attention promptly."
- If you don't know the answer to something, say "I'm sorry, I don't have information on that, but you can try contacting our support or booking an appointment."
- Keep your responses concise and easy to understand.
- Be empathetic and patient.

Available services at ${APP_NAME} that can be booked (service name and ID):
${serviceListForPrompt}

If the user clearly states they want to book one of these specific services, use the "initiateAppointmentBooking" tool. Provide the exact service ID (e.g., "general-consultation", "cardiology"). Only use the tool if they are asking to BOOK. For general questions about services, just answer normally.

User's question: {{{userInput}}}
Answer as MediBuddy.`,
  config: { 
      safetySettings: [
        {
          category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE', 
        },
        {
          category: 'HARM_CATEGORY_HATE_SPEECH',
          threshold: 'BLOCK_ONLY_HIGH',
        },
        {
          category: 'HARM_CATEGORY_HARASSMENT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE',
        },
        {
          category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
          threshold: 'BLOCK_MEDIUM_AND_ABOVE', 
        },
      ],
    }
});

const chatFlow = ai.defineFlow(
  {
    name: 'chatFlow',
    inputSchema: ChatInputSchema,
    outputSchema: ChatOutputSchema,
  },
  async (input: ChatInput): Promise<ChatOutput> => {
    const llmResponse = await chatPrompt(input);
    const allToolRequests = llmResponse.toolRequests; // Access tool requests as a property

    if (allToolRequests && allToolRequests.length > 0) {
      // Find if our specific tool was called.
      // Assuming ToolRequestPart has { name: string, input: any } or { name: string, args: any }
      // Genkit's ToolRequest (part of ToolRequestPart) is typically { name: string, input: T }
      const bookingToolCall = allToolRequests.find(
        (req: { name: string, input: unknown }) => req.name === initiateAppointmentBookingTool.name
      );

      if (bookingToolCall) {
        const toolCallInput = bookingToolCall.input as { serviceId: string }; // Type assertion for safety
        const service = SERVICES_DATA.find(s => s.id === toolCallInput.serviceId);

        if (service) {
          return {
            botResponse: `Great! I'll help you book an appointment for ${service.name}. Please wait while I redirect you.`,
            bookingInitiation: { serviceId: service.id, serviceName: service.name },
          };
        } else {
          // This case should be rare if the LLM follows instructions, but handle it.
          return {
            botResponse: `I tried to start a booking, but I couldn't find a service with ID "${toolCallInput.serviceId}". Can you tell me which service you'd like from the list?`,
          };
        }
      }
      // If other tools were defined, they could be checked and handled here.
    }

    // If the 'initiateAppointmentBookingTool' was not called or not found and processed,
    // or if there were no tool_requests at all, rely on the text response.
    const textResponse = llmResponse.text; // In Genkit v1.x, .text is a property

    // Ensure botResponse is always a string, as per ChatOutputSchema.
    // If textResponse is null/undefined/empty and no relevant tool call was made and handled, provide a default message.
    if (textResponse === null || typeof textResponse === 'undefined' || textResponse.trim() === "") {
        // This path means there's genuinely no text output from the LLM, and our specific tool wasn't successfully handled.
        return { botResponse: "I'm having a little trouble responding right now. Please try again in a moment." };
    }
    
    return { botResponse: textResponse };
  }
);

